    ## 1.1 方格分割

6x6的方格，沿着格子的边线剪开成两部分。
要求这两部分的形状完全相同。

如图：p1.png, p2.png, p3.png 就是可行的分割法。

试计算：
包括这3种分法在内，一共有多少种不同的分割方法。
注意：旋转对称的属于同一种分割法。

请提交该整数，不要填写任何多余的内容或说明文字。

 <img src="img/20200512122732588.png" alt="在这里插入图片描述" style="zoom:80%;" />![在这里插入图片描述](img/20200512123017334.png)  ![在这里插入图片描述](img/20200512123121803.png) 

这题很显然，我没有思路

## 1.2 迷宫

X星球的一处迷宫游乐场建在某个小山坡上。

它是由10x10相互连通的小房间组成的。

房间的地板上写着一个很大的字母。

我们假设玩家是面朝上坡的方向站立，则：

L表示走到左边的房间，

R表示走到右边的房间，

U表示走到上坡方向的房间，

D表示走到下坡方向的房间。

X星球的居民有点懒，不愿意费力思考。

他们更喜欢玩运气类的游戏。这个游戏也是如此！

开始的时候，直升机把100名玩家放入一个个小房间内。

玩家一定要按照地上的字母移动。

迷宫地图如下：

UDDLUULRUL

UURLLLRRRU

RRUURLDLRD

RUDDDDUUUU

URUDLLRRUU

DURLRLDLRL

ULLURLLRDU

RDLULLRDDD

UUDDUDUDLL

ULRDLUURRR

请你计算一下，最后，有多少玩家会走出迷宫?

而不是在里边兜圈子。

请提交该整数，表示走出迷宫的玩家数目，不要填写任何多余的内容。

如果你还没明白游戏规则，可以参看一个简化的4x4迷宫的解说图：

 ![在这里插入图片描述](img/20200624152608525.png) 

很显然 很显然





## 1.3 15.125GB

【问题描述】
在计算机存储中，15.125GB是多少MB？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

> 1KiB（Kilobyte）=1024B ，即2的10次方字节zd，读音“千字节”
> 1MiB（Megabyte）=1024KiB，即2的20次方字内节，读音“兆字节”
> 1GiB（Gigabyte）=1024MiB，即2的30次方字节，读音“吉字节”
> 1TiB（Terabyte）=1024GiB，即2的40次方字节容，读音“太字节”
> 1PiB（Petabyte）=1024TiB，即2的50次方字节，读音“拍字节”
> 1EiB（Exabyte） =1024PiB，即2的60次方字节，读音“艾字节”
> 1ZiB（Zettabyte）=1024EiB，即2的70次方字节，读音“Z字节”
> 1YiB（Yottabyte）=1024ZiB，即2的80次方字节，读音“Y字节
> 比特(bit)是最小的存储单位。
> 计算机存储单位一般用字节(Byte)、千字节(KB)、兆字节(MB)、吉字节(GB)、太字节(TB)、拍字节(PB)、艾字节(EB)、泽它字节(ZB，又称皆字节)、尧它字节(YB)表示。
> ------------------------------------------------
> 版权声明：本文为CSDN博主「大聪明Smart」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/qq_31910669/article/details/106073617

```
capacity = 15.125 * 1024

print(capacity)
```

## 1.4. 约数个数

【问题描述】
1200000有多少个约数（只计算正约数）。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

> 约数，又叫因数。整数a除以整数b(b≠0) 除得的商正好是整数而没有余数，我们就说a能被b整除，或b能整除a。a称为b的倍数，b称为a的约数。在自然数（0和正整数）的范围内，任何正整数都是0的约数。4的正约数有：1、2、4。6的正约数有：1、2、3、6。10的正约数有：1、2、5、10。12的正约数有：1、2、3、41215的正约数有：1、3、5、15。18的正约数有：1、2、3、6、9、18。20的正约数有：1、2、4、5、10、20。注意：一个数的约数必然包括1及其本身。
>
> 

也是送分题，懒得做

```
count = 2  # 1 and itself

num = 1200000

for i in range(2, num):  # From 2 to num - 1
    if num % i == 0:
        count += 1
        # print(i, end=' ')  # Show all divisors

print(count)
```



## 1.5. 叶结点数

【问题描述】
一棵包含有2019个结点的二叉树，最多包含多少个叶结点？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

这题实际上就是求完全二叉树的叶子结点

因为是 **最多** 饱含多少叶节点，那么，AKA 完全二叉树的性质就决定了他这个最多嗷

![1614570696676](img/1614570696676.png)



因为他会布满所有的孩子直到达到上限。

意思就是，我们需要算到2019结点时，那一层的叶结点数和上一层 出度为0  的结点数

现在看看，2019个结点，很明显这棵树是 11层的，这一层剩下的结点很明显是2019-1023=996个

那么上一层是第十层 这一层有512个结点

那么，第十层还有 512-996/2=512-498=14个出度为0 的结点

所以只要用996+14=1010 就是答案

好一点的做法是这样的

```
def most_leaf_nodes(total):

    layer = 0

    while 2 ** layer - 1 < total:
        layer += 1

    now_layer = layer - 1

    now_layer_nodes = 2 ** (layer - 2)

    now_total_nodes = 2 ** (layer - 1) - 1

    left_nodes = total - now_total_nodes

    leaf_nodes = now_layer_nodes - (left_nodes // 2 + left_nodes % 2) + left_nodes

    return leaf_nodes


print(most_leaf_nodes(2019))


```

接下来看这道题

**面试题**：如果一个完全二叉树的结点总数为768个，求叶子结点的个数。

由二叉树的性质知：n0=n2+1，将之带入768=n0+n1+n2中得：768=n1+2n2+1，因为完全二叉树度为1的结点个数要么为0，要么为1，那么就把n1=0或者1都代入公式中，很容易发现n1=1才符合条件。所以算出来n2=383，所以叶子结点个数n0=n2+1=384。

**总结规律**：如果一棵完全二叉树的结点总数为n，那么叶子结点等于n/2（当n为偶数时）或者(n+1)/2（当n为奇数时）

额，更变态的做法是这样的

```
n=int(input())
print(n//2 if n%2==0 else (n+1)//2)
```

## 1.6. 数字9

【问题描述】
在1至2019中，有多少个数的数位中包含数字9？
注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含数字9，在计算只是算一个数。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
------------------------------------------------
送分力

```
c=0
for i in range(1,2020):
    if '9' in str(i):
        c+=1
print(c)

```



## 1.7. 数位递增的数

【问题描述】
一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。
给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？
【输入格式】
输入的第一行包含一个整数 n。
【输出格式】
输出一行包含一个整数，表示答案。
【样例输入】
30
【样例输出】
26
【评测用例规模与约定】
对于 40% 的评测用例，1 <= n <= 1000。
对于 80% 的评测用例，1 <= n <= 100000。
对于所有评测用例，1 <= n <= 1000000。

------------------------------------------------

### 第一种，暴力法

```
n=int(input())
c=0
for i in range(1,n+1):
    s=str(i)
    t=s[0]
    f=True
    for j in s[1:]:
        if j>=t:
            t=j
            f=True
            continue
        else:
            f=False
            break
    if f:
##        print(s)
        c+=1
    
print(c)

```



### 第二种 dp

但是我不会额

GG

```
def dfs(pos, pre, limit):

    if pos == -1:  # 单独一位算一个
        return 1

    if not limit and dp[pos][pre] != -1:  # 返回dp二维表中记录的值
        return dp[pos][pre]

    up = a[pos] if limit else 9

    ans = 0

    for i in range(pre, up + 1):
        ans += dfs(pos - 1, i, limit and i == a[pos])

    if not limit:  # 把算过的值记录在dp二维表中
        dp[pos][pre] = ans

    return ans


def solve(num):
    k = 0
    while num != 0:
        a[k] = num % 10
        k += 1
        num = num // 10

    return dfs(k - 1, 0, True)


a = [0 for _ in range(10)]

dp = [[-1 for _ in range(10)] for _ in range(11)]

n = int(input())

print(solve(n) - 1)

# print(a, dp, sep='\n')


```

## 1.8. 递增三元组

【问题描述】
在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0<i<j<k<n+1 且 a[i]<a[j]<a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。
给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。
【输入格式】
输入的第一行包含一个整数 n。
第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。
【输出格式】
输出一行包含一个整数，表示答案。
【样例输入】
5
1 2 5 3 5
【样例输出】
2
【样例说明】
a[2] 和 a[4] 可能是三元组的中心。
【评测用例规模与约定】
对于 50% 的评测用例，2 <= n <= 100，0 <= 数列中的数 <= 1000。
对于所有评测用例，2 <= n <= 1000，0 <= 数列中的数 <= 10000。

------------------------------------------------
读读题还是很简单的，一个简单的比较而已

```
n = int(input())

arr = list(map(int, input().split()))

count = 0

data = []

for i in range(n):
    for j in range(i + 1, n):
        for k in range(j + 1, n):
            if arr[i] < arr[j] < arr[k]:
                if arr[j] not in data:
                    data.append(arr[j])
                    count += 1
                # count += 1
                # arr[j] = 0

print(count)


```

不过复杂度是有点高了。。

也不知道能不能AC..



### 1.9. 音节判断

【问题描述】
小明对类似于 hello 这种单词非常感兴趣，这种单词可以正好分为四段，第一段由一个或多个辅音字母组成，第二段由一个或多个元音字母组成，第三段由一个或多个辅音字母组成，第四段由一个或多个元音字母组成。
给定一个单词，请判断这个单词是否也是这种单词，如果是请输出yes，否则请输出no。
元音字母包括 a, e, i, o, u，共五个，其他均为辅音字母。
【输入格式】
输入一行，包含一个单词，单词中只包含小写英文字母。
【输出格式】
输出答案，或者为yes，或者为no。
【样例输入】
lanqiao
【样例输出】
yes
【样例输入】
world
【样例输出】
no
【评测用例规模与约定】
对于所有评测用例，单词中的字母个数不超过100。

------------------------------------------------
很明显的贪婪算法

直接贪婪走起

```
word=input()
yuanyin=list('aeiou')
if word[0] in yuanyin:
    print('no')
else:
    i=1
    a=1
    while i<len(word):
        if word[i] not in yuanyin:
            i+=1
        else:
            a+=1
            break

    while i<len(word):
        if word[i] in yuanyin:
            i+=1
        else:
            a+=1
            break

    while i<len(word):
        if word[i] not in yuanyin:
            i+=1
        else:
            a+=1
            break
    while i<len(word):
        if word[i] in yuanyin:
            i+=1
        else:
            a+=1
            break
            
        
        
    if a==4:
        print('yes')
    else:
        print('no')
```



## 1.10. 长草

【问题描述】
小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。
小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。
这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。
请告诉小明，k 个月后空地上哪些地方有草。
【输入格式】
输入的第一行包含两个整数 n, m。
接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。
接下来包含一个整数 k。
【输出格式】
输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。
【样例输入】
4 5
.g...
.....
..g..
.....
2
【样例输出】
gggg.
gggg.
ggggg
.ggg.
【评测用例规模与约定】
对于 30% 的评测用例，2 <= n, m <= 20。
对于 70% 的评测用例，2 <= n, m <= 100。
对于所有评测用例，2 <= n, m <= 1000，1 <= k <= 1000。

这题很明显啊。是一个递归的思想，可以广度优先也可以深度优先啊

```
n,m=map(int,input().split())
grass=[]
for i in range(n):
    grass.append(list(input()))
k=int(input())
mouth=0

def dfs(mouth,i,j):
    print(i,j,mouth)
    if mouth==k or j>=m or i>=n or j<0 or i<0:
        return
    else:
            if j<m-1:
                grass[i][j+1]='g'
                dfs(mouth+1,i,j+1)
            if i<n-1:
                grass[i+1][j]='g'
                dfs(mouth+1,i+1,j)
            if j>0:
                grass[i][j-1]='g'
                dfs(mouth+1,i,j-1)
            if i>0:
                grass[i-1][j]='g'
                dfs(mouth+1,i-1,j)
##            showgrass()
            
            
def showgrass():
    for row in grass:
        print(''.join(row))
 

pos=[]               
for row in range(n):
    for col in range(m):
        if grass[row][col]=='g':
            pos.append((row,col))
for x,y in pos:
    dfs(0,x,y)
        
showgrass()

```

不知道会不会AC额，下一题

## 1.11. 序列计数

【问题描述】
小明想知道，满足以下条件的正整数序列的数量：
1. 第一项为 n；
2. 第二项不超过 n；
3. 从第三项开始，每一项小于前两项的差的绝对值。
请计算，对于给定的 n，有多少种满足条件的序列。
【输入格式】
输入一行包含一个整数 n。
【输出格式】
输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。
【样例输入】
4
【样例输出】
7
【样例说明】
以下是满足条件的序列：
4 1
4 1 1
4 1 2
4 2
4 2 1
4 3
4 4
【评测用例规模与约定】
对于 20% 的评测用例，1 <= n <= 5；
对于 50% 的评测用例，1 <= n <= 10；
对于 80% 的评测用例，1 <= n <= 100；
对于所有评测用例，1 <= n <= 1000。

------------------------------------------------



由于第二项的数目是可以显然得到的，那么可以直接考虑第三项力

对于第一项为n，第二项不超过n的所有可能 显然是 n种

所以用一个for循环容易得到第三项开始的可能有

```
n=int(input())
c=n
for i in range(1,n+1):
    l=[n,i]
    i1=0;i2=1;
    three=abs(l[i1]-l[i2])
    for j in range(1,n+1):
        if j<three:
            c+=1
    
print(c)
```

但其实这样是错的，因为不符合更高的n

所以我们需要想个办法，然后让他转移一下，即保存状态转移

### 1.递归

```
n=int(input())
c=n

def rec(l:list,i:int):
    global c
    print(l)
    three=abs(l[i]-l[i+1])
    for j in range(1,three+1):
        if j<three:
            c+=1
            rec(l+[j],i+1)
        else:
            break
    
for i in range(1,n+1):
    l=[n,i]
    rec(l,0)
    
print(c)
```

递归还是比较好写的

我们来观察一下规律

```
4
[4, 1]
[4, 1, 1]
[4, 1, 2]
[4, 2]
[4, 2, 1]
[4, 3]
[4, 4]
7
```



```
5
[5, 1]
[5, 1, 1]
[5, 1, 2]
[5, 1, 3]
[5, 1, 3, 1]
[5, 1, 3, 1, 1]
[5, 2]
[5, 2, 1]
[5, 2, 2]
[5, 3]
[5, 3, 1]
[5, 3, 1, 1]
[5, 4]
[5, 5]
14
```

```
6
[6, 1]
[6, 1, 1]
[6, 1, 2]
[6, 1, 3]
[6, 1, 3, 1]
[6, 1, 3, 1, 1]
[6, 1, 4]
[6, 1, 4, 1]
[6, 1, 4, 1, 1]
[6, 1, 4, 1, 2]
[6, 1, 4, 2]
[6, 1, 4, 2, 1]
[6, 2]
[6, 2, 1]
[6, 2, 2]
[6, 2, 3]
[6, 3]
[6, 3, 1]
[6, 3, 1, 1]
[6, 3, 2]
[6, 4]
[6, 4, 1]
[6, 4, 1, 1]
[6, 4, 1, 2]
[6, 5]
[6, 6]
26
```

```
7
[7, 1]
[7, 1, 1]
[7, 1, 2]
[7, 1, 3]
[7, 1, 3, 1]
[7, 1, 3, 1, 1]
[7, 1, 4]
[7, 1, 4, 1]
[7, 1, 4, 1, 1]
[7, 1, 4, 1, 2]
[7, 1, 4, 2]
[7, 1, 4, 2, 1]
[7, 1, 5]
[7, 1, 5, 1]
[7, 1, 5, 1, 1]
[7, 1, 5, 1, 2]
[7, 1, 5, 1, 3]
[7, 1, 5, 1, 3, 1]
[7, 1, 5, 1, 3, 1, 1]
[7, 1, 5, 2]
[7, 1, 5, 2, 1]
[7, 1, 5, 2, 2]
[7, 1, 5, 3]
[7, 1, 5, 3, 1]
[7, 1, 5, 3, 1, 1]
[7, 2]
[7, 2, 1]
[7, 2, 2]
[7, 2, 3]
[7, 2, 4]
[7, 2, 4, 1]
[7, 2, 4, 1, 1]
[7, 2, 4, 1, 2]
[7, 3]
[7, 3, 1]
[7, 3, 1, 1]
[7, 3, 2]
[7, 3, 3]
[7, 4]
[7, 4, 1]
[7, 4, 1, 1]
[7, 4, 1, 2]
[7, 4, 2]
[7, 4, 2, 1]
[7, 5]
[7, 5, 1]
[7, 5, 1, 1]
[7, 5, 1, 2]
[7, 5, 1, 3]
[7, 5, 1, 3, 1]
[7, 5, 1, 3, 1, 1]
[7, 6]
[7, 7]
53
```

基本是对的吧？

但是测试需要n=1000，这是AC不了的，没有爆栈但是很慢。

所以要改进一下啊

我们发现有这么一种直接的规律

当n=4和n=5和n=6和n=7时

序列[n,1,...]分别为 3,6,12,24种

序列[n,2,..]分别为2,3,4,8种

序列[n,3,..]分别为1,3,4,5种

序列[n,4,...]分别为1,1,3,6种

额。。

算了，暂时看不出来

换一种思路,以下是n=1~n=13的数目

1,2,4,7,14,26,53,106,220,452,946,1967,4128

额，还是比较难看出来的

所以换一种思路

可以看到又大量重复的数据被利用，所以节省资源的空间很大的，但是我不会

### 2,DP

由于题目问的是 有多少种可能性，我们可以很容易看出这是一道dp的题目

然后我不会了

下一题





## 1.12. 晚会节目单

【问题描述】
小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。
这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。
小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。
小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。
【输入格式】
输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。
第二行包含 n 个整数，依次为每个节目的好看值。
【输出格式】
输出一行包含 m 个整数，为选出的节目的好看值。
【样例输入】
5 3
3 1 2 5 4
【样例输出】
3 5 4
【样例说明】
选择了第1, 4, 5个节目。
【评测用例规模与约定】
对于 30% 的评测用例，1 <= n <= 20；
对于 60% 的评测用例，1 <= n <= 100；
对于所有评测用例，1 <= n <= 100000，0 <= 节目的好看值 <= 100000。

------------------------------------------------
贪心，不知道能不能AC哦，这个好像有点大的数字

```
n,m=map(int,input().split())
likes=list(map(int,input().split()))

maxList=[max(likes[:n-m+1])]
maxIndex=likes.index(maxList[0])
i=1
while len(maxList)<m:
    maxList.append(max(likes[maxIndex+1:n-m+i+1]))
    maxIndex=likes.index(maxList[i])
    i+=1
    
print(*maxList)
```



## 不同字串

一个字符串的非空子串是指字符串中长度至少为1的连续的一段字符组成的串。例如，字符串aaab有非空子串a, b, aa, ab, aaa, aab, aaab，一共7个。 注意在计算时，只算本质不同的串的个数。

请问，字符串0100110001010001有多少个不同的非空子串？

这是一道结果填空的题，你只需要算出结果后提交即可本题的结果为一 个整数，在提交答案时只填写这个整数，
填写多余的内容将无法得分。



由于是连续的，从第一个开始挨个遍历就行

```
##s = '0100110001010001'
s = 'aaab'
subLeng=1 #开始时 连续长度为1
count = 0
_set = set()  # 空集合，利用集合的不重复性
while subLeng <= len(s):
    _set.add(s[0:subLeng])
    # 其实像是双指针的方式
    for i in range(len(s) - subLeng):
        _set.add(s[i+1:i+subLeng+1])  
    subLeng += 1
    count += len(_set)
    print(_set)
    _set.clear()
##    每次的遍历可能有重复，所以要置空
print(count)

```

